[{"title":"Python实现通讯录系统设计","path":"/2024/12/14/Python 实现通讯录系统设计/","content":"演示代码：代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209import tkinter as tkfrom tkinter import ttk, messagebox, filedialogimport jsonimport osclass Contact: def __init__(self, name, phone, email): self.name = name self.phone = phone self.email = email def to_dict(self): return &#123;&quot;name&quot;: self.name, &quot;phone&quot;: self.phone, &quot;email&quot;: self.email&#125;class AddressBook: def __init__(self): self.contacts = [] # 存储Contact对象列表 def add_contact(self, contact: Contact): self.contacts.append(contact) def delete_contact(self, name): self.contacts = [c for c in self.contacts if c.name != name] def search_contact(self, keyword): # 按姓名或电话搜索 keyword = keyword.strip().lower() return [c for c in self.contacts if keyword in c.name.lower() or keyword in c.phone.lower()] def edit_contact(self, old_name, new_contact: Contact): for i, c in enumerate(self.contacts): if c.name == old_name: self.contacts[i] = new_contact return True return False def load_from_file(self, filename): if os.path.exists(filename): with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: data = json.load(f) self.contacts = [Contact(**item) for item in data] else: self.contacts = [] def save_to_file(self, filename): data = [c.to_dict() for c in self.contacts] with open(filename, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(data, f, ensure_ascii=False, indent=4)class AddressBookGUI: def __init__(self, master): self.master = master self.master.title(&quot;通讯录管理系统&quot;) self.address_book = AddressBook() self.filename = &quot;address_book.json&quot; # 初始化界面 self.create_widgets() # 加载数据 self.address_book.load_from_file(self.filename) self.refresh_contact_list() def create_widgets(self): # 搜索框 top_frame = tk.Frame(self.master) top_frame.pack(pady=10) tk.Label(top_frame, text=&quot;搜索（姓名或电话）：&quot;).pack(side=tk.LEFT) self.search_var = tk.StringVar() self.search_entry = tk.Entry(top_frame, textvariable=self.search_var) self.search_entry.pack(side=tk.LEFT, padx=5) tk.Button(top_frame, text=&quot;搜索&quot;, command=self.on_search).pack(side=tk.LEFT, padx=5) tk.Button(top_frame, text=&quot;显示全部&quot;, command=self.on_show_all).pack(side=tk.LEFT, padx=5) # 通讯录列表 self.tree = ttk.Treeview(self.master, columns=(&quot;name&quot;, &quot;phone&quot;, &quot;email&quot;), show=&#x27;headings&#x27;, height=10) self.tree.heading(&quot;name&quot;, text=&quot;姓名&quot;) self.tree.heading(&quot;phone&quot;, text=&quot;电话&quot;) self.tree.heading(&quot;email&quot;, text=&quot;电子邮件&quot;) self.tree.column(&quot;name&quot;, width=100) self.tree.column(&quot;phone&quot;, width=100) self.tree.column(&quot;email&quot;, width=150) self.tree.pack(pady=10) # 按钮区域 btn_frame = tk.Frame(self.master) btn_frame.pack() tk.Button(btn_frame, text=&quot;添加联系人&quot;, command=self.on_add_contact).pack(side=tk.LEFT, padx=5) tk.Button(btn_frame, text=&quot;编辑联系人&quot;, command=self.on_edit_contact).pack(side=tk.LEFT, padx=5) tk.Button(btn_frame, text=&quot;删除联系人&quot;, command=self.on_delete_contact).pack(side=tk.LEFT, padx=5) tk.Button(btn_frame, text=&quot;保存到文件&quot;, command=self.on_save).pack(side=tk.LEFT, padx=5) tk.Button(btn_frame, text=&quot;从文件加载&quot;, command=self.on_load).pack(side=tk.LEFT, padx=5) def refresh_contact_list(self, contacts=None): # 清空列表 for i in self.tree.get_children(): self.tree.delete(i) # 显示所有或指定的联系人 if contacts is None: contacts = self.address_book.contacts for c in contacts: self.tree.insert(&quot;&quot;, tk.END, values=(c.name, c.phone, c.email)) def on_search(self): keyword = self.search_var.get().strip() if keyword: result = self.address_book.search_contact(keyword) self.refresh_contact_list(result) else: messagebox.showinfo(&quot;提示&quot;, &quot;请输入搜索关键词！&quot;) def on_show_all(self): self.refresh_contact_list() def on_add_contact(self): AddEditDialog(self.master, self, mode=&quot;add&quot;) def on_edit_contact(self): selected = self.tree.selection() if not selected: messagebox.showwarning(&quot;警告&quot;, &quot;请先选择要编辑的联系人！&quot;) return item = self.tree.item(selected[0]) old_name, old_phone, old_email = item[&#x27;values&#x27;] AddEditDialog(self.master, self, mode=&quot;edit&quot;, old_name=old_name, old_phone=old_phone, old_email=old_email) def on_delete_contact(self): selected = self.tree.selection() if not selected: messagebox.showwarning(&quot;警告&quot;, &quot;请先选择要删除的联系人！&quot;) return item = self.tree.item(selected[0]) name = item[&#x27;values&#x27;][0] if messagebox.askokcancel(&quot;确认&quot;, f&quot;确定删除联系人 &#123;name&#125; 吗？&quot;): self.address_book.delete_contact(name) self.refresh_contact_list() def on_save(self): self.address_book.save_to_file(self.filename) messagebox.showinfo(&quot;提示&quot;, f&quot;通讯录已保存到文件 &#123;self.filename&#125;&quot;) def on_load(self): file_path = filedialog.askopenfilename(title=&quot;选择通讯录文件&quot;, filetypes=[(&quot;JSON Files&quot;, &quot;*.json&quot;)]) if file_path: self.address_book.load_from_file(file_path) self.refresh_contact_list() messagebox.showinfo(&quot;提示&quot;, &quot;已从文件加载通讯录！&quot;)class AddEditDialog(tk.Toplevel): def __init__(self, master, parent_gui, mode=&quot;add&quot;, old_name=&quot;&quot;, old_phone=&quot;&quot;, old_email=&quot;&quot;): super().__init__(master) self.parent_gui = parent_gui self.mode = mode self.old_name = old_name self.old_phone = old_phone self.old_email = old_email if self.mode == &quot;add&quot;: self.title(&quot;添加联系人&quot;) else: self.title(&quot;编辑联系人&quot;) tk.Label(self, text=&quot;姓名：&quot;).grid(row=0, column=0, pady=5, padx=5, sticky=tk.E) tk.Label(self, text=&quot;电话：&quot;).grid(row=1, column=0, pady=5, padx=5, sticky=tk.E) tk.Label(self, text=&quot;电子邮件：&quot;).grid(row=2, column=0, pady=5, padx=5, sticky=tk.E) self.name_var = tk.StringVar(value=self.old_name) self.phone_var = tk.StringVar(value=self.old_phone) self.email_var = tk.StringVar(value=self.old_email) tk.Entry(self, textvariable=self.name_var).grid(row=0, column=1, pady=5, padx=5) tk.Entry(self, textvariable=self.phone_var).grid(row=1, column=1, pady=5, padx=5) tk.Entry(self, textvariable=self.email_var).grid(row=2, column=1, pady=5, padx=5) btn_frame = tk.Frame(self) btn_frame.grid(row=3, column=0, columnspan=2, pady=10) tk.Button(btn_frame, text=&quot;确定&quot;, command=self.on_ok).pack(side=tk.LEFT, padx=10) tk.Button(btn_frame, text=&quot;取消&quot;, command=self.destroy).pack(side=tk.LEFT, padx=10) def on_ok(self): name = self.name_var.get().strip() phone = self.phone_var.get().strip() email = self.email_var.get().strip() if not name or not phone: messagebox.showwarning(&quot;警告&quot;, &quot;姓名和电话为必填项！&quot;) return new_contact = Contact(name, phone, email) if self.mode == &quot;add&quot;: # 添加新联系人 self.parent_gui.address_book.add_contact(new_contact) else: # 编辑联系人 success = self.parent_gui.address_book.edit_contact(self.old_name, new_contact) if not success: messagebox.showerror(&quot;错误&quot;, &quot;编辑联系人失败！&quot;) return self.parent_gui.refresh_contact_list() self.destroy()if __name__ == &quot;__main__&quot;: root = tk.Tk() app = AddressBookGUI(root) root.mainloop() 地址json文件： 1234567891011121314151617181920212223242526272829303132[ &#123; &quot;name&quot;: &quot;张三&quot;, &quot;phone&quot;: &quot;123456789&quot;, &quot;email&quot;: &quot;zhangsan@example.com&quot; &#125;, &#123; &quot;name&quot;: &quot;李四&quot;, &quot;phone&quot;: &quot;987654321&quot;, &quot;email&quot;: &quot;lisi@example.com&quot; &#125;, &#123; &quot;name&quot;: &quot;王五&quot;, &quot;phone&quot;: &quot;111111111&quot;, &quot;email&quot;: &quot;wangwu@example.com&quot; &#125;, &#123; &quot;name&quot;: &quot;赵六&quot;, &quot;phone&quot;: &quot;222222222&quot;, &quot;email&quot;: &quot;zhaoliu@example.com&quot; &#125;, &#123; &quot;name&quot;: &quot;钱七&quot;, &quot;phone&quot;: &quot;333333333&quot;, &quot;email&quot;: &quot;qianqi@example.com&quot; &#125;, &#123; &quot;name&quot;: &quot;乙&quot;, &quot;phone&quot;: &quot;234567890&quot;, &quot;email&quot;: &quot;jia@example.com&quot; &#125;] 一、流程图（过程设计图）下面的流程图示意了程序的核心交互与各功能模块之间的关系，可以把它理解成用户使用该通讯录程序时的“操作-响应”流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162┌─────────────────────────┐│ 启动程序 ││ (创建主窗口 + 初始化 ││ AddressBookGUI实例) │└────────────┬────────────┘ │ │ (1)加载数据 ▼┌─────────────────────────┐│ load_from_file(filename) ││ 如果文件存在 -&gt; 加载联系人 ││ 否则contacts为空列表 │└────────────┬────────────┘ │ │ (2)主界面 ▼┌─────────────────────────┐│ 主界面显示联系人列表 ││ 提供以下功能按钮： ││ 1) 搜索联系人 ││ 2) 显示全部 ││ 3) 添加联系人 ││ 4) 编辑联系人 ││ 5) 删除联系人 ││ 6) 保存到文件 ││ 7) 从文件加载 │└────────────┬────────────┘ │ ├───────── [搜索联系人] ──────────┐ │ │ │ (3a) 用户输入搜索关键词 │ │ -&gt; 调用search_contact │ │ -&gt; 刷新列表只显示匹配结果 │ │ │ ├───────── [添加联系人] ──────────┐ │ │ │ (3b) 弹出对话框AddEditDialog │ │ -&gt; 用户输入姓名/电话等信息│ │ -&gt; AddressBook.add_contact │ -&gt; 刷新联系人列表 │ │ │ ├───────── [编辑联系人] ──────────┐ │ │ │ (3c) 选中某联系人，弹出AddEditDialog │ -&gt; 编辑并更新到AddressBook │ -&gt; 刷新联系人列表 │ │ ├───────── [删除联系人] ──────────┐ │ │ │ (3d) 选中某联系人 -&gt; delete_contact │ -&gt; 刷新联系人列表 │ │ ├───────── [保存到文件] ──────────┐ │ │ │ (3e) save_to_file(filename) │ │ -&gt; JSON格式写入 │ │ │ └───────── [从文件加载] ──────────┘ │ ▼ load_from_file(用户选择的文件) -&gt; 刷新联系人列表 收起 流程图解释： 启动程序：运行 address_book.py 或 tongxunlu.py 时，会创建 Tk 主窗口，并实例化 AddressBookGUI。 加载数据：在 AddressBookGUI.__init__ 里，通过 load_from_file 尝试加载保存的 JSON 文件。如果文件存在且数据正确，就把读取的列表转成 Contact 对象存进 contacts 列表；若不存在则为空。 主界面：Tkinter GUI界面呈现在用户面前，显示联系人列表 + 功能按钮。 用户在主界面可执行以下操作： 搜索联系人：在搜索框里输入姓名或电话的关键词，调用 AddressBook.search_contact 返回匹配结果，并刷新列表。 添加联系人：弹出对话框输入姓名、电话、Email，确认后将新 Contact 对象加入通讯录并刷新列表。 编辑联系人：选中一行并点击编辑，弹出对话框修改信息；调用 AddressBook.edit_contact 更新后刷新。 删除联系人：选中一行并点击删除，调用 AddressBook.delete_contact 删掉匹配的对象。 保存到文件：调用 save_to_file(filename)，将当前联系人列表序列化为JSON并写到本地。 从文件加载：打开文件选择对话框，加载选定的 JSON 文件。 二、功能与模块分析下面列出该项目的主要功能模块及其实现思路、关键步骤。与前述流程图对应，这些步骤有助于理解代码的逻辑结构与数据流向。 1. 数据结构模块 Contact类 用于封装单个联系人的信息：name, phone, email。 to_dict()方法可把对象转成字典，以便JSON序列化存储。 AddressBook类 内含一个列表 self.contacts，每个元素都是 Contact 对象。 提供对联系人增删改查的方法： add_contact(contact) delete_contact(name) search_contact(keyword) edit_contact(old_name, new_contact) 提供文件读写方法： load_from_file(filename): 读取JSON文件并转成 Contact 对象列表 save_to_file(filename): 将 contacts 列表序列化写入JSON文件 2. GUI界面（Tkinter）模块 主窗口 AddressBookGUI 初始化 ： 创建 AddressBook 实例 定义存储文件名（如 address_book.json） 调用 load_from_file 加载通讯录数据 构建并摆放各种UI组件（搜索框、按钮、TreeView列表等） 核心功能按钮 ： 搜索：读取搜索框内容 -&gt; 调 search_contact -&gt; 刷新列表 显示全部：直接显示所有 contacts 添加联系人：弹出对话框 AddEditDialog(mode=&quot;add&quot;)；成功后刷新列表 编辑联系人：选中联系人，带着旧信息进入对话框；成功编辑后刷新列表 删除联系人：选中联系人 -&gt; delete_contact -&gt; 刷新列表 保存到文件：save_to_file -&gt; 序列化到 JSON 从文件加载：打开文件对话框选择文件 -&gt; load_from_file -&gt; 刷新列表 TreeView 组件 用于在主窗口中央显示联系人信息的表格。 每行对应一个 Contact，包含姓名、电话、电子邮件三列。 通过 refresh_contact_list(contacts=None) 方法刷新表格显示数据。 添加&#x2F;编辑联系人对话框 AddEditDialog 当点击“添加联系人”或“编辑联系人”时弹出。 包含姓名、电话、电子邮件三个 Entry 输入框和“确定&#x2F;取消”按钮。 如果是添加模式(mode=&quot;add&quot;)：填完信息后调用 address_book.add_contact()。 如果是编辑模式(mode=&quot;edit&quot;)：带入旧的信息；用户修改完点击确定后，调用 address_book.edit_contact(old_name, new_contact)。 3. 文件读写与JSON格式 保存文件 (save_to_file) 将 contacts 列表里的 Contact 对象转成字典 [c.to_dict() for c in self.contacts]。 调用 json.dump(data, f, ensure_ascii=False, indent=4) 写入本地JSON文件。 JSON大致格式: 123456789101112[ &#123; &quot;name&quot;: &quot;张三&quot;, &quot;phone&quot;: &quot;123456&quot;, &quot;email&quot;: &quot;zhangsan@example.com&quot; &#125;, &#123; &quot;name&quot;: &quot;李四&quot;, &quot;phone&quot;: &quot;987654&quot;, &quot;email&quot;: &quot;lisi@example.com&quot; &#125;] 加载文件 (load_from_file) json.load(f) 解析JSON文件，得到一个列表。 列表内每个元素是一个dict，包含&quot;name&quot;, &quot;phone&quot;, &quot;email&quot;等字段。 循环创建 Contact(**item) 并加入 contacts。 4. 异常处理与扩展 如果JSON文件不存在或格式不对，会抛异常或导致读取失败。 可以在加载阶段做额外的防护，如捕获 JSONDecodeError，在界面弹出友好提示；或自动初始化空列表。 界面美化可使用 ttk.Style 或改进布局管理。 实际项目中往往需要数据库持久化或更多字段（地址、备注、生日等），原理与本示例相同，但需要额外的数据结构和表单输入。 测试截图： ![cd47201c6a77b0e0a9c4bdaa8d28c76](C:\\Users\\wxi7641\\Documents\\WeChat Files\\wxid_pyp924ky216w22\\FileStorage\\Temp\\cd47201c6a77b0e0a9c4bdaa8d28c76.png) ![aca466039d05b9a2b0a4f2942352305](C:\\Users\\wxi7641\\Documents\\WeChat Files\\wxid_pyp924ky216w22\\FileStorage\\Temp\\aca466039d05b9a2b0a4f2942352305.png)"},{"path":"/2024/07/24/Markdown语法综述/","content":"什么是Markdown? Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 为什么要使用Markdown Markdown 可以用于一切。包括可以使用它来创建网站、文档、笔记、书籍、演示文稿、电子邮件和技术文档。 Markdown 具有可移植性。包含 Markdown 格式文本的文件几乎可以使用任何应用程序打开。如果不喜欢当前使用的 Markdown 应用程序，则可以将 Markdown 文件导入另一个 Markdown 应用程序。 Markdown 独立于平台。可以在任何运行任何操作系统的设备上创建 Markdown 格式的文本。 Markdown 是面向未来的。即使使用的应用程序在未来某个时候停止工作，仍然可以使用文本编辑应用程序阅读 Markdown 格式的文本。 Markdown 无处不在。Reddit 和 GitHub 等网站都支持Markdown，许多桌面和基于 Web 的应用程序也支持它。 Markdown基本语法1. 标题使用 # 加空格来添加标题，其数量即为标题等级，一般只能做到1-6级。 [!标题演示] 一级标题二级标题三级标题四级标题五级标题六级标题 3. 段落格式(1)段落段落的换行有两种方式： 第一种是直接在段落末尾加两个空格 第二种是在段落下一行使用空格两种方式都可，区别在之间的间距。如果你转换md-html，你可以看到第一种：123&lt;p&gt;这是第一段的第一行。&lt;br&gt;这是第一段的第二行。&lt;/p&gt; 第二种：1234&lt;p&gt;这是第二段的第一行。&lt;/p&gt;&lt;p&gt;这是第二段的第二行。&lt;/p&gt; 这就是两者之间的差别。 (2)字体markdown有很多修饰字体的方法，如斜体、粗体、粗斜体、添加删除线等 我是斜体 斜体 在文字左右用*或_修饰我是粗体 粗体 同斜体符号，使用两个一样的我是粗斜体 粗斜体 同上，使用三个一样的我是删除线 删除线 使用两个~我是下划线 下划线 使用u标签&#x3D;&#x3D;我是高亮&#x3D;&#x3D; 高亮 使用两个= 为保护兼容性，推荐使用* 而不是_，此外，下划线在如果支持html的md编辑器里可以用u标签，有些没有兼容的编辑器可能有其他方法，在此不赘述。 (3)脚注对文本补充说明创建脚注引用，可以在[]内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注引用与脚注本身相关联 — 在输出中，脚注是按顺序编号的。[^1] [要注明的文本 ] : 脚注允许您添加注释和引用，创建脚注时，添加脚注引用的位置会显示一个带有链接的上标编号。读者可以点击链接跳转到页面底部的脚注内容。(若没有则是编辑器不支持) 4.列表(1)有序列表有序列表使用数字并加上 . 号再加上空格来表示 第一项 第二项 第三项 (2)无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，注意这些标记后面要添加一个空格 第一项 第一项 第一项 (3)任务列表任务列表（也称为清单和待办事项列表）允许创建带有复选框的项目列表。使-和[] 加空格来创建，要选中复选框，在之间添加一个x. 12- [x] a- [ ] b a b (4)列表嵌套只需在子列表中的选项前面添加两个或四个空格即可 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示结果： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 5. 区块 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号 另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： 123&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套 显示结果： 最外层 第一层嵌套 第二层嵌套 此外，区块和列表在使用时有很多嵌套方式 区块中使用列表 12345&gt; 区块中使用列表&gt; 1. 第一项&gt; * 第一项&gt; + 第二项&gt; - 第三项 显示： 区块中使用列表 第一项 第一项 第二项 第三项 列表中使用区块需要在&gt;前添加四个空格的缩进。1234* 第一项 &gt; first &gt; second* 第二项 显示： 第一项 firstsecond 第二项 6. 代码单个函数或代码片段使用&#96; &#96;&#96;来包括使用；代码区块 使用 4 个空格或者一个制表符（Tab 键) 使用tab 使用空格 三个点号 7. 链接链接使用方法如下： 123`[链接名称](链接地址)``或者``&lt;链接地址&gt;` 可以跟脚注连用 [!连接展示]这个链接用 1 作为网址变量 [Google][1]然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ 8. 图片图片语法格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 方括号，里面放图片的替代文字，普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。与链接一样可以与脚注连用，不在演示。 9. 表格 制作表格使用 |来分隔不同的单元格，使用 - 来分隔表头和其他行。 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 展示： 表头 表头 单元格 单元格 单元格 单元格 可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 展示： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 注：表格的上下两行不宜有字。 参考资料：Markdown Guide_https://www.markdownguide.org/菜鸟教程Markdown 教程 | 菜鸟教程 (runoob.com)维基百科_ https://zh.wikipedia.org/wiki/Markdown","tags":["基础语法","开发工具"]},{"path":"/2024/07/23/基于java+mvc框架的铁路订票系统设计/","content":"基于java+mvc框架的铁路订票系统设计介绍本项目基于java+mysal+html+css+javascript+Tomcat等技术开发，旨在实现包括用户管理、预约查询、订票买票等项目在前后端和数据库的交互性系统。"},{"path":"/2024/06/17/随笔6.17/","content":"随笔6.17随写 大梦如幻，夜度桃花界三千，醒时浮屠一场空。 若云与梦同幻，及草地而坠，拥风而落席。 花草低语，鸟涧从鸣，不知高阳忽坠，不识月黯徐来。 冯明而毗落，月影故归息。 伏兮随风起，万物从梦生。 故有梦而幻，有幻而空坠，空坠故不言、不语、不假、不真。 见岁时稍转，逢天地之不界。 故醒而一枕黄粱，若有即若无。"},{"title":"Hello World","path":"/2024/03/31/hello-world/","content":"介绍​ 本网站基于Github提供的免费域名gitHub.io在hexo框架下搭建使用，主要内容和用途可能包括分享日常生活，记录项目实践开发以及没事在网上发发疯等等。 ​ 博客这种东西，常而有言，大概是自娱自乐，闲散时玩玩的东西。至于真有人靠这玩意丰富简历，规划个人学习生活的，确实大有其在，但不如哥们这样的摆子多，所以该网站是我24年过年前搭建的，二月到三月末出现一堆问题，懒得改，最后拖到现在快7月才想起来并改完成。中间搭建的过程以前写过，但markdown文件删了，反正现在也懒得再重写，之后开个虚拟机重新建一次记录一下（鬼知道我会拖多久，反正立个flat得了） Hello World​ 很多人说写这个当开头可能会有好的兆头，不管是代码还是网站。站长是不信这些玩意儿的，但是不想行为上太特立独行，免得之后被别人看到了，先问我一句：哎哥们，你网站第一篇咋没写Hello World啊？我再回他说我懒得写，明显是我随便糊弄一下更省心静神。把人当主题，当一个人降生的时候，有人直接对他说“Hello World”吗？当然是没有的。但父母的期盼，亲人（族人）的挂念，医院（或类似机构，如果不在就相关助生人员）医生和护士的守望，或许我们现在的生活是可以一眼望到死的，但不能否定当初那个呱呱落地的自己······其实吧，刚生下来时，大概是啥也不知道的，被外界人定义行为与感知，在随岁月流逝后逐渐融入，并在一些方面深深不能自拔。这样想来，就很能理解有乐山居士五岁前闭口不言的典故流传于世了。岁不长，语人长。人如故，事事故。"}]